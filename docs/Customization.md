# Customizations

OpenAPI and Swagger type providers one or several provided API client (depending on the value of `IgnoreControllerPrefix`).
Each provided API client is subclass of `ProvidedApiClientBase` that allow you control and customize HTTP calls.

```fsharp
type ProvidedApiClientBase(httpClient: HttpClient) =
    member val HttpClient = httpClient with get, set

    abstract member Serialize: obj -> string
    abstract member Deserialize: string * Type -> obj
```

Snippet shows only most important parts of `ProvidedApiClientBase`, the full source code provide default implementation for `Serialize` & `Deserialize` methods that tightly coupled with [Newtonsoft.Json](https://www.nuget.org/packages/Newtonsoft.Json/).

**Key features:**
1. You can provide your own instance of `HttpClient` during API client construction and control HTTP request execution (If you will not provide `HttpClient`, type provider create default one for you).
2. `Serialize` and `Deserialize` methods are abstract. If you are not happy with default `JsonSerializerSettings` you can override them and configure `Newtonsoft.Json` as you like.

## Request interception

Since you control `HttpClient` you are able to use [Outgoing request middleware](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-3.0#outgoing-request-middleware) implement your own `DelegatingHandler` and intercept all HTTP request generated by provided API client.

```fsharp {highlight:['8-13','18-20']}
open System
open System.Net.Http
open SwaggerProvider

let [<Literal>] Schema = "https://petstore.swagger.io/v2/swagger.json"
type PetStore = OpenApiClientProvider<Schema, PreferAsync=true>

type LoggingHandler(messageHandler) =
    inherit DelegatingHandler(messageHandler)
    override __.SendAsync(request, cancellationToken) =
        // Put break point here is want to debug HTTP calls
        printfn "[%A]: %A" request.Method request.RequestUri
        base.SendAsync(request, cancellationToken)

[<EntryPoint>]
let main argv =
    let baseAddress = Uri("https://petstore.swagger.io/v2/")
    let handler1 = new HttpClientHandler (UseCookies = false)
    let handler2 = new LoggingHandler(handler1)
    use httpClient = new HttpClient(handler2, true, BaseAddress=baseAddress)
    let client = PetStore.Client(httpClient)
    async {
        let pet = PetStore.Pet(Id = Some(24L), Name = "Shani")
        do! client.AddPet(pet)
        let! myPet = client.GetPetById(24L)
        printfn "Waw, my name is %A" myPet.Name
    }
    |> Async.RunSynchronously
    0
```

## Authentication

Authentication is just a special case `Request interception`. Your custom `DelegatingHandler` is fully responsible for management of authentication information (attach Authentication Header, authentication cookie, invalidate it and etc.).

```fsharp {highlight:['4-6']}
type AuthHandler(messageHandler) =
    inherit DelegatingHandler(messageHandler)
    override __.SendAsync(request, cancellationToken) =
        // Invalidate your token if it expired
        request.Headers.Authorization <-
            Headers.AuthenticationHeaderValue("Bearer", "Your OAuth token");
        base.SendAsync(request, cancellationToken)
```

if your token does not require invalidation, you can use `HttpClient.DefaultRequestHeaders` to add your `Authorization` header to all requests

```fsharp {highlight:['4-5']}
let baseAddress = Uri("https://petstore.swagger.io/v2/")
let handler = new HttpClientHandler (UseCookies = false)
use httpClient = new HttpClient(handler, true, BaseAddress=baseAddress)
httpClient.DefaultRequestHeaders.Authorization <-
    Headers.AuthenticationHeaderValue("Bearer", "Your OAuth token")
let client = PetStore.Client(httpClient)
```

## Serialization 

Serialization is also quite flexible. All you need it to define your own type for API client that will be subclass of API client generated by type provider and override `Serialize` and `Deserialize` members.

<Note type="note">

Serializer is configurable but not replaceable! Type provider emit type with [JsonPropertyAttribute](https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_JsonPropertyAttribute.htm) on properties for seamless serialization.

</Note>

```fsharp {highlight:['20-28', '33-34']}
open System
open SwaggerProvider
open System.Text.Json
open System.Text.Json.Serialization

let [<Literal>] Schema = "https://petstore.swagger.io/v2/swagger.json"
type PetStore = OpenApiClientProvider<Schema, PreferAsync=true>

let jsonSerializerSettings =
    // nuget: System.Text.Json
    let settings = JsonSerializerOptions(
                    //PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,
                    // ...
                    IgnoreNullValues = true
    ) 
    // nuget: FSharp.SystemTextJson
    JsonFSharpOptions.Default().AddToJsonSerializerOptions settings
    settings

type MyApiClient() =
    // inherit from provided API client
    inherit PetStore.Client()

    // Overload default implementation of Serialize & Deserialize
    override __.Serialize(value:obj): string =
        JsonSerializer.Serialize(value, jsonSerializerSettings)
    override __.Deserialize(value, retTy:Type): obj =
        JsonSerializer.Deserialize(value, retTy, jsonSerializerSettings)


[<EntryPoint>]
let main argv =
    // Instantiate your API client
    let client = MyApiClient()
    async {
        let pet = PetStore.Pet(Id = Some(24L), Name = "Shani")
        do! client.AddPet(pet)
        let! myPet = client.GetPetById(24L)
        printfn "Waw, my name is %A" myPet.Name
    }
    |> Async.RunSynchronously
    0

```